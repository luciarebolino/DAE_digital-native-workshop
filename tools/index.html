<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Street View Camera Visualizer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: Arial, sans-serif;
            font-weight: normal;
            background: #fff;
            color: #000;
            overflow: hidden;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        #controls {
            position: absolute;
            top: 15px;
            left: 15px;
            bottom: 15px;
            background: transparent;
            padding: 15px;
            width: 280px;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            color: #000;
        }
        .control-group {
            margin-bottom: 12px;
        }
        label {
            display: block;
            margin-bottom: 4px;
            font-size: 12px;
            color: #333;
            font-weight: normal;
        }
        input[type="range"] {
            width: 100%;
            margin-bottom: 4px;
        }
        select, button {
            width: 100%;
            padding: 6px;
            background: #f0f0f0;
            color: #000;
            border: 1px solid #ccc;
            cursor: pointer;
            margin-bottom: 8px;
            font-size: 12px;
            font-weight: normal;
            font-family: Arial, sans-serif;
        }
        button:hover, select:hover {
            background: #e0e0e0;
        }
        .value-display {
            color: #000;
            font-weight: normal;
        }
        h3 {
            margin-bottom: 12px;
            font-size: 13px;
            border-bottom: 1px solid #ddd;
            padding-bottom: 8px;
            font-weight: normal;
            color: #000;
        }
        #videoDisplay {
            position: absolute;
            bottom: 15px;
            left: 15px;
            width: 560px;
            height: 320px;
            background: #ffffff;
            display: none;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }
        #videoDisplay img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
    </style>
</head>
<body>
    <!-- Import camera parameter files (auto-generated by camera-XX-*.js scripts) -->
    <script src="camera-params-01.js"></script>
    <script src="camera-params-02.js"></script>
    <script src="camera-params-03.js"></script>
    <script src="camera-params-04.js"></script>
    <script src="camera-params-05.js"></script>
    <script src="camera-params-06.js"></script>
    <script src="camera-params-07.js"></script>
    
    <div id="canvas-container"></div>
    <div id="videoDisplay">
        <img id="videoImage" src="" alt="Video Frame">
    </div>
    <div id="controls">
        <div class="control-group">
            <label><span style="color: #00ff00;">FOV:</span> <span id="fovValue" class="value-display">90°</span> (120°-1°)</label>
            <input type="range" id="fov" min="10" max="120" value="90" step="1">
        </div>
        
        <div class="control-group">
            <label><span style="color: #0000ff;">Heading:</span> <span id="headingValue" class="value-display">0°</span> (0°-360°)</label>
            <input type="range" id="heading" min="0" max="360" value="0" step="1">
        </div>
        
        <div class="control-group">
            <label><span style="color: #ff0000;">Pitch:</span> <span id="pitchValue" class="value-display">0°</span> (-90°/+90°)</label>
            <input type="range" id="pitch" min="-90" max="90" value="0" step="1">
        </div>
        
        <div class="control-group">
            <label>Camera Movement:</label>
            <select id="cameraAnimation">
                <option value="">None</option>
                <option value="cam01-static">01: Static</option>
                <option value="cam02-zoom">02: Zoom</option>
                <option value="cam03-rotation">03: Rotation</option>
                <option value="cam04-pitch">04: Pitch</option>
                <option value="cam05-combined">05: Combined</option>
                <option value="cam06-superzoom">06: Super Zoom</option>
                <option value="cam08-spiral">08: Spiral</option>
            </select>
        </div>
        
        <div class="control-group">
            <label>Video:</label>
            <select id="imageSelect">
                <option value="">None</option>
                <option value="video-zoom">Zoom (120° → 1°)</option>
                <option value="video-superzoom">Super Zoom (Digital)</option>
                <option value="video-combined">Combined</option>
                <option value="video-spiral">Spiral</option>
            </select>
        </div>
        
        <div id="frameControl" class="control-group" style="display: none;">
            <label>Frame: <span id="frameValue" class="value-display">1</span></label>
            <input type="range" id="frameSlider" min="1" max="200" value="1" step="1">
        </div>
        
        <div class="control-group">
            <label>Path:</label>
            <button id="playPath">▶ Play</button>
        </div>
        
        <div class="control-group">
            <label>Point: <span id="pointValue" class="value-display">1</span> / <span id="totalPoints" class="value-display">2718</span></label>
            <input type="range" id="pathSlider" min="0" max="100" value="0" step="1">
        </div>
        
        <div class="control-group">
            <label>Lat: <span id="latValue" class="value-display">0.000</span></label>
            <label>Lon: <span id="lonValue" class="value-display">0.000</span></label>
        </div>
        
        <button id="resetView">Reset</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);
        
        const mainCamera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        const mainRenderer = new THREE.WebGLRenderer({ antialias: true });
        mainRenderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('canvas-container').appendChild(mainRenderer.domElement);
        
        // Lights
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.4);
        dirLight.position.set(5, 10, 5);
        scene.add(dirLight);
        
        const sphereRadius = 4;
        
        // Create a group for the camera location (moves along path)
        const cameraLocationGroup = new THREE.Group();
        cameraLocationGroup.position.set(0, 0, 0);
        scene.add(cameraLocationGroup);
        
        // Main camera control - orbits around camera location group
        function updateMainCameraView() {
            const cameraDistance = 15;
            mainCamera.position.set(
                cameraLocationGroup.position.x + cameraDistance * Math.sin(cameraRotationY) * Math.cos(cameraRotationX),
                cameraLocationGroup.position.y + 3 + cameraDistance * Math.sin(cameraRotationX),
                cameraLocationGroup.position.z + cameraDistance * Math.cos(cameraRotationY) * Math.cos(cameraRotationX)
            );
            mainCamera.lookAt(cameraLocationGroup.position);
        }
        
        let cameraRotationX = 0.3;
        let cameraRotationY = 0.5;
        let cameraDistance = 15;
        updateMainCameraView();
        
        // 360° sphere (wireframe) - MOVES WITH PATH
        const sphereGeometry = new THREE.SphereGeometry(sphereRadius, 64, 64);
        const cameraSphere = new THREE.Mesh(
            sphereGeometry,
            new THREE.MeshBasicMaterial({ 
                color: 0x1a1a1a,
                wireframe: false,
                transparent: true,
                opacity: 0
            })
        );
        // cameraSphere not added to scene - completely hidden
        
        // Location point at CENTER (black dot at camera position)
        const locationPoint = new THREE.Mesh(
            new THREE.SphereGeometry(0.15, 16, 16),
            new THREE.MeshBasicMaterial({ color: 0x000000 })
        );
        cameraLocationGroup.add(locationPoint);
        
        // HEADING & PITCH INDICATORS (lines and circles only, no text labels)
        function createIndicators() {
            const group = new THREE.Group();
            const lineLength = 5;
            
            // Pitch indicator line (RED - Y axis)
            const pitchLineGeom = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, -lineLength, 0),
                new THREE.Vector3(0, lineLength, 0)
            ]);
            const pitchLine = new THREE.Line(pitchLineGeom, new THREE.LineBasicMaterial({ color: 0xff1111, linewidth: 3, transparent: true, opacity: 0.8 }));
            group.add(pitchLine);
            group.pitchLine = pitchLine;
            
            // Heading indicator circle (BLUE - heading/compass)
            const headingPoints = [];
            const headingSegments = 64;
            for (let i = 0; i <= headingSegments; i++) {
                const angle = (i / headingSegments) * Math.PI * 2;
                headingPoints.push(
                    new THREE.Vector3(
                        Math.cos(angle) * lineLength,
                        0,
                        Math.sin(angle) * lineLength
                    )
                );
            }
            const headingGeometry = new THREE.BufferGeometry().setFromPoints(headingPoints);
            const headingCircle = new THREE.Line(headingGeometry, new THREE.LineBasicMaterial({ color: 0x1111ff, linewidth: 3, transparent: true, opacity: 0.8 }));
            group.add(headingCircle);
            group.headingCircle = headingCircle;
            
            return group;
        }
        
        const indicatorsGroup = createIndicators();
        cameraLocationGroup.add(indicatorsGroup);
        
        // Image projection mesh
        let imageMesh = null;
        let fovHighlight = null;
        const textureLoader = new THREE.TextureLoader();
        
        function createImageProjection(imagePath) {
            if (imageMesh) {
                cameraLocationGroup.remove(imageMesh);
                imageMesh = null;
            }
            if (fovHighlight) {
                cameraLocationGroup.remove(fovHighlight);
                fovHighlight = null;
            }
            
            if (!imagePath) return;
            
            textureLoader.load(
                imagePath,
                (texture) => {
                    const fov = parseFloat(document.getElementById('fov').value);
                    const fovRad = THREE.MathUtils.degToRad(fov);
                    
                    // Create plane that will be positioned on sphere
                    // The width/height should match the cone opening at the sphere distance
                    const width = 2 * sphereRadius * Math.tan(fovRad / 2);
                    const height = width; // Square to fill circular FOV
                    
                    const planeGeometry = new THREE.PlaneGeometry(width, height, 32, 32);
                    
                    // Bend the plane to match sphere curvature
                    const positions = planeGeometry.attributes.position;
                    for (let i = 0; i < positions.count; i++) {
                        const x = positions.getX(i);
                        const y = positions.getY(i);
                        
                        // Project onto sphere
                        const distance = Math.sqrt(x*x + y*y + sphereRadius*sphereRadius);
                        const scale = sphereRadius * 0.98 / distance;
                        
                        positions.setXYZ(i, x * scale, y * scale, -Math.sqrt(sphereRadius*sphereRadius*0.98*0.98 - x*x*scale*scale - y*y*scale*scale));
                    }
                    positions.needsUpdate = true;
                    planeGeometry.computeVertexNormals();
                    
                    imageMesh = new THREE.Mesh(
                        planeGeometry,
                        new THREE.MeshBasicMaterial({ 
                            map: texture,
                            side: THREE.DoubleSide,
                            transparent: true,
                            opacity: 0.95
                        })
                    );
                    
                    // Create FOV highlight on sphere (yellow outline showing projection imprint)
                    const highlightGeometry = new THREE.BufferGeometry();
                    const highlightPositions = [];
                    const segments = 64;
                    for (let i = 0; i <= segments; i++) {
                        const angle = (i / segments) * Math.PI * 2;
                        const x = Math.cos(angle) * width / 2;
                        const y = Math.sin(angle) * height / 2;
                        
                        // Project onto sphere
                        const distance = Math.sqrt(x*x + y*y + sphereRadius*sphereRadius);
                        const scale = sphereRadius * 0.99 / distance;
                        const px = x * scale;
                        const py = y * scale;
                        const pz = -Math.sqrt(sphereRadius*sphereRadius*0.99*0.99 - px*px - py*py);
                        
                        highlightPositions.push(px, py, pz);
                    }
                    highlightGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(highlightPositions), 3));
                    
                    fovHighlight = new THREE.Line(
                        highlightGeometry,
                        new THREE.LineBasicMaterial({ 
                            color: 0x00ff00,
                            linewidth: 3,
                            transparent: true,
                            opacity: 0.8
                        })
                    );
                    
                    cameraLocationGroup.add(imageMesh);
                    cameraLocationGroup.add(fovHighlight);
                    updateVisualization();
                },
                undefined,
                (error) => console.log('Could not load image:', imagePath)
            );
        }
        
        // FOV PYRAMID - Shows the actual field of view boundaries (like green sketch)
        const fovConeGroup = new THREE.Group();
        fovConeGroup.position.set(0, 0, 0);
        cameraLocationGroup.add(fovConeGroup);
        
        const pyramidHeight = sphereRadius * 2;
        let fovCone = null;
        let fovConeEdges = null;
        
        function createFOVPyramid(fovDegrees) {
            // Remove old pyramid
            if (fovCone) fovConeGroup.remove(fovCone);
            if (fovConeEdges) fovConeGroup.remove(fovConeEdges);
            
            const fovRad = THREE.MathUtils.degToRad(fovDegrees);
            
            // Create pyramid geometry that represents the FOV
            // The pyramid shows the cone of vision with edges aligned to sphere projection
            const geometry = new THREE.BufferGeometry();
            
            // Pyramid vertices:
            // Tip at origin (camera)
            const vertices = [
                0, 0, 0,  // 0: tip (camera)
            ];
            
            // Four corners of the pyramid base at distance pyramidHeight
            // Half-angle of FOV
            const halfAngle = fovRad / 2;
            const baseRadius = pyramidHeight * Math.tan(halfAngle);
            
            // Create 4 corners of square at the base
            vertices.push(baseRadius, baseRadius, -pyramidHeight);    // 1: top-right
            vertices.push(-baseRadius, baseRadius, -pyramidHeight);   // 2: top-left
            vertices.push(-baseRadius, -baseRadius, -pyramidHeight);  // 3: bottom-left
            vertices.push(baseRadius, -baseRadius, -pyramidHeight);   // 4: bottom-right
            
            geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices), 3));
            
            // Create triangular faces (pyramid sides)
            const indices = [
                // Base square
                1, 2, 3,
                1, 3, 4,
                // Pyramid sides
                0, 1, 2,  // top face
                0, 2, 3,  // left face
                0, 3, 4,  // bottom face
                0, 4, 1   // right face
            ];
            
            geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(indices), 1));
            geometry.computeVertexNormals();
            
            fovCone = new THREE.Mesh(
                geometry,
                new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.15,
                    side: THREE.DoubleSide
                })
            );
            fovConeGroup.add(fovCone);
            
            // Create edges (green outline like your sketch)
            const edges = new THREE.EdgesGeometry(geometry);
            fovConeEdges = new THREE.LineSegments(
                edges,
                new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: 2 })
            );
            fovConeGroup.add(fovConeEdges);
        }
        
        // Create initial pyramid
        createFOVPyramid(90);
        
        // Path line (shows the route)
        let pathLine = null;
        
        function createPathLine(points) {
            if (pathLine) {
                scene.remove(pathLine);
            }
            
            if (points.length < 2) return;
            
            // Convert lat/lon to 3D coordinates
            const pathPoints3D = points.map((pt, index) => {
                const x = (pt.lon + 5.537) * 1000 - 5;
                const z = (pt.lat - 36.032) * 1000 - 5;
                return new THREE.Vector3(x, 0, z);
            });
            
            const pathGeometry = new THREE.BufferGeometry().setFromPoints(pathPoints3D);
            pathLine = new THREE.Line(
                pathGeometry,
                new THREE.LineBasicMaterial({ 
                    color: 0xff00ff,
                    linewidth: 1,
                    transparent: true,
                    opacity: 0.6
                })
            );
            scene.add(pathLine);
        }
        
        function updatePositionMarker(index) {
            // Magenta marker removed - it's now at same position as white dot
        }
        
        // Path data
        let pathPoints = [];
        let currentPathIndex = 0;
        let isPlayingPath = false;
        
        // Load path points from points.geojson
        fetch('../points.geojson')
            .then(response => response.json())
            .then(data => {
                pathPoints = data.features.map((feature, index) => ({
                    lat: feature.geometry.coordinates[1],
                    lon: feature.geometry.coordinates[0],
                    heading: feature.properties.angle || 0,
                    index: index
                }));
                document.getElementById('pathSlider').max = pathPoints.length - 1;
                document.getElementById('totalPoints').textContent = pathPoints.length;
                createPathLine(pathPoints);
                // Load first point at start
                updatePathPosition(0);
                console.log(`Loaded ${pathPoints.length} path points`);
            })
            .catch(error => console.error('Could not load path:', error));
        
        // Controls
        const fovSlider = document.getElementById('fov');
        const headingSlider = document.getElementById('heading');
        const pitchSlider = document.getElementById('pitch');
        const imageSelect = document.getElementById('imageSelect');
        const frameSlider = document.getElementById('frameSlider');
        const frameControl = document.getElementById('frameControl');
        const videoDisplay = document.getElementById('videoDisplay');
        const videoImage = document.getElementById('videoImage');
        const pathSlider = document.getElementById('pathSlider');
        const playPathButton = document.getElementById('playPath');
        const resetButton = document.getElementById('resetView');
        const cameraAnimationSelect = document.getElementById('cameraAnimation');
        
        let isVideoMode = false;
        let currentVideoType = '';
        let activeCameraAnimation = '';
        let animationStartTime = 0;
        let glowTimeout = null;
        
        // Glow effect function - increases brightness/opacity
        function glowEffect(duration = 0.5) {
            // Clear previous timeout
            if (glowTimeout) clearTimeout(glowTimeout);
            
            // Increase opacity to make brighter
            if (indicatorsGroup.pitchLine) indicatorsGroup.pitchLine.material.opacity = 1.0;
            if (indicatorsGroup.headingCircle) indicatorsGroup.headingCircle.material.opacity = 1.0;
            if (fovCone) fovCone.material.opacity = 0.4;
            if (fovConeEdges) fovConeEdges.material.opacity = 1.0;
            
            // Reset opacity after duration
            glowTimeout = setTimeout(() => {
                if (indicatorsGroup.pitchLine) indicatorsGroup.pitchLine.material.opacity = 0.8;
                if (indicatorsGroup.headingCircle) indicatorsGroup.headingCircle.material.opacity = 0.8;
                if (fovCone) fovCone.material.opacity = 0.15;
                if (fovConeEdges) fovConeEdges.material.opacity = 1.0;
            }, duration * 1000);
        }
        
        function getVideoConfig(videoType) {
            const configs = {
                'video-zoom': {
                    folder: './output_zoom',
                    maxFrames: 200,
                    getFOV: (progress) => 120 - (120 - 1) * Math.pow(progress, 3.5)
                },
                'video-superzoom': {
                    folder: './output_superzoom',
                    maxFrames: 202,
                    getFOV: (progress) => {
                        if (progress < 0.5) {
                            // Phase 1: API zoom 120° → 1°
                            const p = progress * 2;
                            return 120 - (120 - 1) * Math.pow(p, 3.5);
                        } else {
                            // Phase 2: Digital zoom, FOV stays at 1°
                            return 1;
                        }
                    }
                },
                'video-combined': {
                    folder: './output_combined',
                    maxFrames: 200,
                    getFOV: (progress) => 90 - (90 - 30) * Math.pow(progress, 2),
                    getPitch: (progress) => 30 * Math.sin(progress * Math.PI * 3),
                    getHeading: (progress) => (progress * 360 + 45 * Math.sin(progress * Math.PI * 5)) % 360
                },
                'video-spiral': {
                    folder: './output_spiral_08',
                    maxFrames: 200,
                    getFOV: (progress) => 5 + (90 - 5) * Math.pow(progress, 1.5),
                    getPitch: (progress) => -45 + progress * 90,
                    getHeading: (progress) => {
                        // Oscillate left-right in a spiral pattern, amplitude shrinks
                        const angle = progress * Math.PI * 2 * 6;
                        const spiralAmplitude = 90 * (1 - Math.pow(progress, 1.2));
                        return (spiralAmplitude * Math.sin(angle)) % 360;
                    }
                },
                'video-satellite': {
                    folder: './output_satellite_superzoom',
                    maxFrames: 202,
                    getFOV: (progress) => {
                        // Satellite doesn't use FOV, but we can estimate
                        // Zoom level 12-21 roughly maps to FOV
                        if (progress < 0.6) {
                            return 90 - progress * 80; // Approximation
                        }
                        return 10; // Digital zoom phase
                    }
                }
            };
            return configs[videoType];
        }
        
        function loadVideoFrame(frameNumber, videoType) {
            const config = getVideoConfig(videoType);
            if (!config) return;
            
            const paddedFrame = String(frameNumber).padStart(5, '0');
            const imagePath = `${config.folder}/${paddedFrame}.jpg`;
            const progress = (frameNumber - 1) / (config.maxFrames - 1);
            const fovValue = config.getFOV(progress);
            
            fovSlider.value = fovValue;
            frameSlider.max = config.maxFrames;
            
            // Apply pitch if config has it
            if (config.getPitch) {
                const pitchValue = config.getPitch(progress);
                pitchSlider.value = pitchValue;
            }
            
            // Apply heading if config has it
            if (config.getHeading) {
                const headingValue = config.getHeading(progress);
                headingSlider.value = headingValue;
            }
            
            videoImage.src = imagePath;
            createImageProjection(imagePath);
            updateVisualization();
        }
        
        function updateVisualization() {
            const fov = parseFloat(fovSlider.value);
            const heading = parseFloat(headingSlider.value);
            const pitch = parseFloat(pitchSlider.value);
            
            // Update displays
            document.getElementById('fovValue').textContent = Math.round(fov) + '°';
            document.getElementById('headingValue').textContent = Math.round(heading) + '°';
            document.getElementById('pitchValue').textContent = Math.round(pitch) + '°';
            
            // Convert to radians
            const headingRad = THREE.MathUtils.degToRad(heading);
            const pitchRad = THREE.MathUtils.degToRad(pitch);
            const fovRad = THREE.MathUtils.degToRad(fov);
            
            // Recreate FOV pyramid with new FOV value
            createFOVPyramid(fov);
            
            // Apply rotations to pyramid: heading then pitch
            fovConeGroup.rotation.order = 'YXZ';
            fovConeGroup.rotation.y = headingRad;
            fovConeGroup.rotation.x = pitchRad;  // Positive pitch = looking up
            
            
            // Update image mesh if exists
            // The image mesh borders should align with the pyramid edges
            if (imageMesh) {
                // Scale the image plane to match the FOV pyramid opening
                const scale = Math.tan(fovRad / 2);
                imageMesh.scale.set(scale, scale, scale);
                
                imageMesh.rotation.order = 'YXZ';
                imageMesh.rotation.y = headingRad;
                imageMesh.rotation.x = pitchRad;
            }
            
            // Update FOV highlight on sphere
            if (fovHighlight) {
                fovHighlight.rotation.order = 'YXZ';
                fovHighlight.rotation.y = headingRad;
                fovHighlight.rotation.x = pitchRad;
            }
            
            // Update both camera views
            updateMainCameraView();
        }
        
        function updatePathPosition(index) {
            if (index < 0 || index >= pathPoints.length) return;
            
            currentPathIndex = index;
            const pt = pathPoints[index];
            
            // Convert lat/lon to 3D coordinates (same as path marker)
            const x = (pt.lon + 5.537) * 1000 - 5;
            const y = 0;
            const z = (pt.lat - 36.032) * 1000 - 5;
            
            // Move the entire camera location group along the path
            cameraLocationGroup.position.set(x, y, z);
            
            // Update heading based on path direction
            headingSlider.value = pt.heading;
            
            // Display lat/lon coordinates
            document.getElementById('latValue').textContent = pt.lat.toFixed(6);
            document.getElementById('lonValue').textContent = pt.lon.toFixed(6);
            
            document.getElementById('pointValue').textContent = index + 1;
            pathSlider.value = index;
            
            updatePositionMarker(index);
            updateVisualization();
        }
        
        function animatePath() {
            if (!isPlayingPath || pathPoints.length === 0) return;
            
            currentPathIndex = (currentPathIndex + 1) % pathPoints.length;
            updatePathPosition(currentPathIndex);
            
            setTimeout(animatePath, 100); // 100ms per point
        }
        
        function updateCameraAnimation() {
            if (!activeCameraAnimation) return;
            
            const elapsed = (Date.now() - animationStartTime) / 1000;
            const cycle = elapsed % 4; // 4 second cycle
            const progress = cycle / 4;
            
            // Try to load static parameters from camera config
            const match = activeCameraAnimation.match(/cam(\d+)/);
            let paramsLoaded = false;
            let params = null;
            
            if (match) {
                const cameraNum = match[1];
                const paramsName = `CAMERA_${cameraNum}_PARAMS`;
                if (window[paramsName]) {
                    params = window[paramsName];
                    paramsLoaded = true;
                }
            }
            
            switch (activeCameraAnimation) {
                case 'cam01-static':
                    // Static: no movement
                    headingSlider.value = params?.HEADING_OFFSET ?? 0;
                    pitchSlider.value = params?.PITCH ?? 0;
                    fovSlider.value = params?.FOV ?? 90;
                    break;
                    
                case 'cam02-zoom':
                    // Zoom: FOV 120° → 1° (exponential curve 3.5)
                    const zoomProg = Math.pow(progress, 3.5);
                    fovSlider.value = params?.FOV_START ?? 120;
                    fovSlider.value = (params?.FOV_START ?? 120) - ((params?.FOV_START ?? 120) - (params?.FOV_END ?? 1)) * zoomProg;
                    headingSlider.value = params?.HEADING_OFFSET ?? 0;
                    pitchSlider.value = params?.PITCH ?? 0;
                    break;
                    
                case 'cam03-rotation':
                    // Rotation: static FOV and PITCH, but animate heading
                    const rotationDegrees = params?.ROTATION_DEGREES ?? 720;
                    headingSlider.value = (progress * rotationDegrees) % 360;
                    fovSlider.value = params?.FOV ?? 90;
                    pitchSlider.value = params?.PITCH ?? 0;
                    break;
                    
                case 'cam04-pitch':
                    // Pitch: static FOV and heading, but animate pitch
                    const pitchSine = Math.sin(progress * Math.PI * 2 * 4);
                    const pitchAmplitude = params?.PITCH_AMPLITUDE ?? 45;
                    pitchSlider.value = pitchSine * pitchAmplitude;
                    fovSlider.value = params?.FOV ?? 90;
                    headingSlider.value = params?.HEADING_OFFSET ?? 0;
                    break;
                    
                case 'cam05-combined':
                    // Combined: Rotation + Pitch simultaneously
                    const combinedRotation = params?.ROTATION_DEGREES ?? 360;
                    headingSlider.value = (progress * combinedRotation) % 360;
                    const combinedPitch = Math.sin(progress * Math.PI * 2 * 2) * (params?.PITCH_AMPLITUDE ?? 45);
                    pitchSlider.value = combinedPitch;
                    fovSlider.value = params?.FOV ?? 90;
                    break;
                    
                case 'cam06-superzoom':
                    // Super Zoom: First 50% API zoom (120° → 1°), then digital zoom
                    if (progress < 0.5) {
                        const apiZoom = Math.pow(progress * 2, 3.5);
                        const fovStart = params?.FOV_START ?? 120;
                        const fovEnd = params?.FOV_END ?? 1;
                        fovSlider.value = fovStart - (fovStart - fovEnd) * apiZoom;
                    } else {
                        fovSlider.value = params?.FOV_END ?? 1; // Lock at min FOV for digital zoom phase
                    }
                    headingSlider.value = params?.HEADING_OFFSET ?? 0;
                    pitchSlider.value = params?.PITCH ?? 0;
                    break;
                    
                case 'cam08-spiral':
                    // Spiral weave: oscillate left-right getting tighter while zooming in
                    const angle = progress * Math.PI * 2 * 6;
                    const spiralAmplitude = (params?.SPIRAL_AMPLITUDE ?? 90) * (1 - Math.pow(progress, 1.2));
                    const spiralHeading = (spiralAmplitude * Math.sin(angle)) % 360;
                    const fovStart7 = params?.FOV_START ?? 5;
                    const fovEnd7 = params?.FOV_END ?? 90;
                    fovSlider.value = fovStart7 + (fovEnd7 - fovStart7) * Math.pow(progress, 1.5);
                    headingSlider.value = spiralHeading;
                    pitchSlider.value = (params?.PITCH_START ?? -45) + progress * ((params?.PITCH_END ?? 45) - (params?.PITCH_START ?? -45));
                    break;
            }
            
            isPlayingPath = false;
            playPathButton.textContent = '▶ Play Path';
            updateVisualization();
        }
        
        // Event listeners
        fovSlider.addEventListener('input', () => {
            if (isVideoMode) {
                isVideoMode = false;
                videoDisplay.style.display = 'none';
                frameControl.style.display = 'none';
            }
            glowEffect(0.5);
            updateVisualization();
        });
        
        headingSlider.addEventListener('input', () => {
            isPlayingPath = false;
            playPathButton.textContent = '▶ Play Path';
            glowEffect(0.5);
            updateVisualization();
        });
        
        pitchSlider.addEventListener('input', () => {
            glowEffect(0.5);
            updateVisualization();
        });
        
        imageSelect.addEventListener('change', (e) => {
            const value = e.target.value;
            
            if (value.startsWith('video-')) {
                isVideoMode = true;
                currentVideoType = value;
                frameControl.style.display = 'block';
                videoDisplay.style.display = 'flex';
                frameSlider.value = 1;
                loadVideoFrame(1, value);
            } else {
                isVideoMode = false;
                currentVideoType = '';
                frameControl.style.display = 'none';
                videoDisplay.style.display = 'none';
            }
        });
        
        frameSlider.addEventListener('input', (e) => {
            const frameNumber = parseInt(e.target.value);
            document.getElementById('frameValue').textContent = frameNumber;
            if (currentVideoType) {
                // Connect frame to path point
                // Calculate which point index this frame corresponds to
                const config = getVideoConfig(currentVideoType);
                const frameProgress = (frameNumber - 1) / (config.maxFrames - 1);
                const pointIndex = Math.round(frameProgress * (pathPoints.length - 1));
                updatePathPosition(pointIndex);
                loadVideoFrame(frameNumber, currentVideoType);
            }
        });
        
        headingSlider.addEventListener('input', () => {
            isPlayingPath = false;
            playPathButton.textContent = '▶ Play Path';
            updateVisualization();
        });
        
        pitchSlider.addEventListener('input', updateVisualization);
        
        pathSlider.addEventListener('input', (e) => {
            isPlayingPath = false;
            playPathButton.textContent = '▶ Play Path';
            updatePathPosition(parseInt(e.target.value));
        });
        
        playPathButton.addEventListener('click', () => {
            isPlayingPath = !isPlayingPath;
            playPathButton.textContent = isPlayingPath ? '⏸ Pause Path' : '▶ Play Path';
            if (isPlayingPath) animatePath();
        });
        
        resetButton.addEventListener('click', () => {
            cameraRotationX = 0.3;
            cameraRotationY = 0.5;
            fovSlider.value = 90;
            headingSlider.value = 0;
            pitchSlider.value = 0;
            isPlayingPath = false;
            playPathButton.textContent = '▶ Play Path';
            activeCameraAnimation = '';
            cameraAnimationSelect.value = '';
            updateVisualization();
        });
        
        cameraAnimationSelect.addEventListener('change', (e) => {
            activeCameraAnimation = e.target.value;
            if (activeCameraAnimation) {
                animationStartTime = Date.now();
                
                // Load parameters from camera config and update sliders
                // Extract camera number from dropdown value (e.g., "cam03-rotation" -> "03")
                const match = activeCameraAnimation.match(/cam(\d+)/);
                if (match) {
                    const cameraNum = match[1];
                    const paramsName = `CAMERA_${cameraNum}_PARAMS`;
                    if (window[paramsName]) {
                        const params = window[paramsName];
                        // Update sliders with camera parameters
                        if (params.FOV !== undefined) {
                            fovSlider.value = params.FOV;
                            document.getElementById('fovValue').textContent = Math.round(params.FOV) + '°';
                        }
                        if (params.PITCH !== undefined) {
                            pitchSlider.value = params.PITCH;
                            document.getElementById('pitchValue').textContent = Math.round(params.PITCH) + '°';
                        }
                        if (params.HEADING_OFFSET !== undefined) {
                            headingSlider.value = params.HEADING_OFFSET;
                            document.getElementById('headingValue').textContent = Math.round(params.HEADING_OFFSET) + '°';
                        }
                        updateVisualization();
                    }
                }
            }
        });
        
        // Mouse controls
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        
        mainRenderer.domElement.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            
            const deltaX = e.clientX - previousMousePosition.x;
            const deltaY = e.clientY - previousMousePosition.y;
            
            cameraRotationY += deltaX * 0.01;
            cameraRotationX += deltaY * 0.01;
            cameraRotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraRotationX));
            
            updateMainCameraView();
            
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });
        
        document.addEventListener('mouseup', () => {
            isDragging = false;
        });
        
        mainRenderer.domElement.addEventListener('wheel', (e) => {
            e.preventDefault();
            cameraDistance += e.deltaY * 0.01;
            cameraDistance = Math.max(5, Math.min(30, cameraDistance));
            updateMainCameraView();
        });
        
        // Window resize
        window.addEventListener('resize', () => {
            const w = window.innerWidth;
            const h = window.innerHeight;
            mainCamera.aspect = w / h;
            mainCamera.updateProjectionMatrix();
            mainRenderer.setSize(w, h);
        });
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            updateCameraAnimation();
            mainRenderer.render(scene, mainCamera);
        }
        
        // Initialize
        updateVisualization();
        animate();
    </script>
</body>
</html>
